import{_ as o,o as e,c as a,N as l}from"./chunks/framework.60272d8a.js";const g=JSON.parse('{"title":"MongoDB - 入门指南 - 程序员翔仔 - 博客园","description":"","frontmatter":{},"headers":[],"relativePath":"knowledge/数据库/MongoDB入门指南.md","lastUpdated":1706686109000}'),i={name:"knowledge/数据库/MongoDB入门指南.md"},d=l(`<h1 id="mongodb-入门指南-程序员翔仔-博客园" tabindex="-1">MongoDB - 入门指南 - 程序员翔仔 - 博客园 <a class="header-anchor" href="#mongodb-入门指南-程序员翔仔-博客园" aria-label="Permalink to &quot;MongoDB - 入门指南 - 程序员翔仔 - 博客园&quot;">​</a></h1><h2 id="组件结构" tabindex="-1">组件结构 <a class="header-anchor" href="#组件结构" aria-label="Permalink to &quot;组件结构&quot;">​</a></h2><h3 id="核心进程" tabindex="-1">核心进程 <a class="header-anchor" href="#核心进程" aria-label="Permalink to &quot;核心进程&quot;">​</a></h3><p>在 MongoDB 中，核心进程主要包含了 mongod、mongos 和 mongosh 三个。</p><p>其中最主要的是 mongod 程序，其在不同的部署方案中（单机部署、副本集部署、分片集群部署），通过不同的配置，可以扮演多种不同的角色：</p><ul><li>在单机部署中作为数据库服务器（提供所有读写功能）</li><li>在副本集部署中，通过配置，可以部署为 Primary 节点（负责写数据，也可以提供查询）、Secondary 节点（从主节点复制数据，也可以提供查询）、以及 Arbiter 节点（不保存数据，主要用于参与选举投票）</li><li>在分片集群中，除了在每个分片中扮演上述角色外，还扮演着配置服务器的角色（存储有分片集群的所有元数据信息，mongos 的数据路由分发等都要依赖于它）</li></ul><p>在一台服务器上，可以启动多个 mongod 服务。但在实际生产部署中，通常是建议一台服务器部署一个 mongod 实例，这样不仅减少资源竞争，而且服务器故障也不会同时影响到多个服务。</p><p>mongos 在分片集群中扮演路由的角色，提供客户端和分片之间的接口。</p><p>mongosh 是 MongoDB 集成的交互式 shell 工具。</p><h3 id="数据库工具" tabindex="-1">数据库工具 <a class="header-anchor" href="#数据库工具" aria-label="Permalink to &quot;数据库工具&quot;">​</a></h3><p>MongoDB 数据库工具是用于处理 MongoDB 部署的命令行实用程序的集合。数据库工具包括以下二进制文件：</p><ul><li>二进制导入导出 <ul><li>mongodump: 导出 mongod 数据库的二进制数据</li><li>mongorestore: 恢复 mongodump 导出文件的数据到 mongod 或 mongos 数据库</li><li>bsondump: 转换 BSON 导出文件成 JSON 格式</li></ul></li><li>数据导入导出 <ul><li>mongoimport: 从外部 JSON、CSV 或 TSV 文件中加载数据</li><li>mongoexport: 从 mongod 实例中导出数据到 JSON 或 CSV 文件中</li></ul></li><li>诊断工具 <ul><li>mongostat: 快速诊断当前运行的 mongod 或 mongos 实例的状态</li><li>mongotop: 统计 mongod 实例读取和写入数据的时间</li></ul></li><li>GridFS 工具 <ul><li>mongofiles: 支持在 GridFS 对象中操作 MongoDB 实例中存储的文件</li></ul></li></ul><h2 id="数据逻辑结构" tabindex="-1">数据逻辑结构 <a class="header-anchor" href="#数据逻辑结构" aria-label="Permalink to &quot;数据逻辑结构&quot;">​</a></h2><p>MongoDB 数据逻辑结构分为数据库 database、集合 collection、文档 document 三层 :</p><ul><li>一个 mongod 实例中允许创建多个数据库</li><li>一个数据库中允许创建多个集合，集合相当于关系型数据库的表</li><li>一个集合则是由若干个文档构成，文档相当于关系型数据库的行，是 MongoDB 中数据的基本单元</li></ul><h3 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h3><p>一个数据库中可以创建多个集合，原则上应把逻辑相近的集合都放在一个数据库中。</p><p>在 MongoDB 中，会有以下几个内建的数据库：</p><ul><li>admin: 存放有数据库帐号相关信息，在身份验证和授权时使用</li><li>local: 特定于单个服务器的数据会存储在此数据库中。在副本集中，local 数据库用于存储复制过程中所使用的数据，而其本身不会被复制。</li><li>config: 用于分片集群环境，存放了分片相关的元数据信息</li><li>test: 默认创建的测试库，连接 mongod 服务时，如果不指定连接的具体数据库，默认就会连接到 test 数据库</li></ul><h3 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h3><p>和 SQL 的表不同，集合是动态模式，不需要在读写数据前创建模式就可以使用，集合中的文档也可以拥有不同的字段，随时可以任意增减某个文档的字段。</p><p>默认情况下，集合不要求其文档具有相同的模式，但这是一种很好的实践。可以通过使用 MongoDB 的文档验证功能和可用于多种编程语言的对象–文档映射（object-document mapping）库来实现文档验证。</p><p>集合由其名称进行标识，集合名称可以是任意 UTF-8 字符串，但有以下限制：</p><ul><li>不能是空字符串（<code>&quot;&quot;</code>）。</li><li>不能含有 <code>\\0</code>（空字符），这个字符用于表示集合名称的结束</li><li>不能以 <code>system.</code> 开头，该前缀为内部集合保留</li></ul><p>集合名称使用 <code>.</code> 字符可以创建子集合，用与区分不同组织集合。虽然子集合没有任何特殊属性，但它们很有用，许多 MongoDB 工具整合了子集合。</p><h3 id="文档" tabindex="-1">文档 <a class="header-anchor" href="#文档" aria-label="Permalink to &quot;文档&quot;">​</a></h3><p>文档是 MongoDB 中数据的基本存储单元，以一种叫作 BSON 的文档结构表示。</p><p>文档中的键值对是有序的，不同序则是不同文档。并且键是区分大小写的，否则也为不同文档。</p><p>文档的键是字符串，而值除了字符串，还可以是 <code>Int</code>、<code>Long</code>、<code>Double</code>、<code>Boolean</code>、数组、嵌入文档等多种类型。</p><p>每个文档都有一个默认的 <code>_id</code> 键，它相当于关系型数据库中的主键，这个键的值在同一个集合中必须是唯一的。</p><p><code>_id</code> 键的值默认是 <code>ObjectId</code> 类型，在插入文档的时候，如果用户不设置文档的 <code>_id</code> 值的话，MongoDB 会自动生成一个唯一的 <code>ObjectId</code> 值进行填充。</p><h2 id="数据库文件" tabindex="-1">数据库文件 <a class="header-anchor" href="#数据库文件" aria-label="Permalink to &quot;数据库文件&quot;">​</a></h2><p>MongoDB 在 3.2 版本已经将 WiredTiger 作为默认的存储引擎。其作为存储引擎的时候，数据库会有以下存储文件：</p><ul><li><code>collection-*.wt</code>: 存储集合的数据</li><li><code>index-*.wt</code>: 存储索引的数据</li><li><code>WiredTiger</code>: 存储基本配置信息</li><li><code>WiredTiger.wt</code>: 存储所有其他集合的元数据信息</li><li><code>WiredTiger.lock</code>: 存储进程 ID，用于防止多个进程连接同一个 WiredTiger 数据库</li><li><code>WiredTiger.turtle</code>: 存储 <code>WiredTiger.wt</code> 的元数据信息</li><li><code>journal</code>: 存储数据库的写日志</li></ul><h2 id="命令行工具" tabindex="-1">命令行工具 <a class="header-anchor" href="#命令行工具" aria-label="Permalink to &quot;命令行工具&quot;">​</a></h2><p>MongoDB 提供的 mongosh 是一个 JavaScript 的 shell，其提供了许多高级功能和自定义功能。</p><h3 id="使用技巧" tabindex="-1">使用技巧 <a class="header-anchor" href="#使用技巧" aria-label="Permalink to &quot;使用技巧&quot;">​</a></h3><p>对于 MongoDB 提供的功能，shell 内置了帮助文档，可以输入 <code>help</code> 命令进行访问，使用 <code>db.help()</code> 可以查看数据库级别的帮助文档，使用 <code>db.foo.help()</code> 可以查看集合级别的帮助文档。</p><p>在 shell 中使用函数之前，在不使用括号的情况下输入函数名，这样会打印出函数的源代码，这是一个可以查看函数具体行为的好方法。</p><h3 id="执行脚本" tabindex="-1">执行脚本 <a class="header-anchor" href="#执行脚本" aria-label="Permalink to &quot;执行脚本&quot;">​</a></h3><p>shell 不止可以直接执行 JavaScript 的脚本代码，还可以用于执行 JavaScript 的脚本文件，简单执行 <code>mongo script.js</code> 即可。</p><p>如果已经进入到 shell 中，可以使用 <code>load()</code> 函数加载 JavaScript 脚本文件。</p><h3 id="创建-mongorc-js-文件" tabindex="-1">创建 .mongorc.js 文件 <a class="header-anchor" href="#创建-mongorc-js-文件" aria-label="Permalink to &quot;创建 .mongorc.js 文件&quot;">​</a></h3><p>对于需要频繁被加载的脚本，可以将它们添加到 <code>.mongorc.js</code> 中，此文件会在启动 shell 时自动运行。</p><p>在更实际一些的场景中，使用此脚本可以设置全局变量，或者为长名称设置一个简短的别名，也可以重写内置函数。</p><h3 id="定制提示信息" tabindex="-1">定制提示信息 <a class="header-anchor" href="#定制提示信息" aria-label="Permalink to &quot;定制提示信息&quot;">​</a></h3><p>通过将 <code>prompt</code> 变量设置为一个字符串或函数，可以重写默认的 shell 提示，如下示例：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">prompt = function() {    if (typeof db == &#39;undefined&#39;) {        return &#39;(nodb)&gt; &#39;;    }     // 检查最后的数据库操作    try {        db.runCommand({getLastError: 1});    } catch (e) {        print(e);    }     return db+&quot;&gt; &quot;;};</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>提示函数应该返回一个字符串，通常应该包含对 <code>getLastError</code> 的调用，这样可以捕获输入时的错误，并在 shell 断开连接时自动重新连接。</p><h3 id="编辑复杂变量" tabindex="-1">编辑复杂变量 <a class="header-anchor" href="#编辑复杂变量" aria-label="Permalink to &quot;编辑复杂变量&quot;">​</a></h3><p>使用 shell 时，编辑多行的时候不能再编辑前面的行，这对于较大的代码块或对象非常不友好。</p><p>为此，可以在 shell 中设置 <code>EDITOR</code> 变量，则可以使用 <code>edit varname</code> 的方式编辑一个变量，完成更改后只需保存并退出编辑器，变量将被重新解析并加载回 shell 中。</p><h3 id="不便使用的集合名称" tabindex="-1">不便使用的集合名称 <a class="header-anchor" href="#不便使用的集合名称" aria-label="Permalink to &quot;不便使用的集合名称&quot;">​</a></h3><p>大多数情况下可以使用 <code>db.collectionName</code> 语法来获得一个集合的内容，但如果集合名称是保留字或是无效的 JavaScript 属性名称时，那么此方法就不能正常工作了。</p><p>对于上述的情况，可以使用 <code>db.getCollection()</code> 的方式绕过无效属性。</p>`,55),n=[d];function r(t,c,s,p,h,m){return e(),a("div",null,n)}const b=o(i,[["render",r]]);export{g as __pageData,b as default};
