import{_ as s,o as a,c as e,N as n}from"./chunks/framework.60272d8a.js";const m=JSON.parse('{"title":"javascript - HTTP缓存和浏览器的本地存储","description":"","frontmatter":{},"headers":[],"relativePath":"guide/js/HTTP缓存和浏览器的本地存储.md","lastUpdated":1706686109000}'),o={name:"guide/js/HTTP缓存和浏览器的本地存储.md"},t=n(`<h1 id="javascript-http缓存和浏览器的本地存储" tabindex="-1">javascript - HTTP缓存和浏览器的本地存储 <a class="header-anchor" href="#javascript-http缓存和浏览器的本地存储" aria-label="Permalink to &quot;javascript - HTTP缓存和浏览器的本地存储&quot;">​</a></h1><h2 id="一、http缓存" tabindex="-1">一、HTTP缓存 <a class="header-anchor" href="#一、http缓存" aria-label="Permalink to &quot;一、HTTP缓存&quot;">​</a></h2><p>http请求做为影响前端性能极为重要的一环，因为请求受网络影响很大，如果网络很慢的情况下,页面很可能会空白很久。对于<strong>首次进入</strong>网站的用户可能要通过优化接口性能和接口数量来解决。但是，对于<strong>重复进入</strong>页面的用户，除了浏览器缓存，http缓存可以很大程度对已经加载过的页面进行优化。</p><h3 id="_1-缓存位置" tabindex="-1">1.缓存位置 <a class="header-anchor" href="#_1-缓存位置" aria-label="Permalink to &quot;1.缓存位置&quot;">​</a></h3><p><img src="https://segmentfault.com/img/bVbwrBF?w=782&amp;h=356" alt="clipboard.png" title="clipboard.png"></p><p>从缓存位置上来看，分为4种，从上往下依次检查是否命中，如果但都没有命中则重新发起请求。<br><strong>Service Worker</strong> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。<br><strong>Memory Cache</strong> 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。<br> 内存缓存中有一块重要的缓存资源是preloader相关指令（例如<link rel="prefetch">）下载的资源。它可以一边解析js/css文件，一边网络请求下一个资源。<br><strong>Disk Cache</strong> 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。<br> 绝大部分的缓存都来自Disk Cache，在HTTP 的协议头中设置。<br><strong>Push Cache</strong>（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><h3 id="_2-用户操作对缓存的影响" tabindex="-1">2.用户操作对缓存的影响 <a class="header-anchor" href="#_2-用户操作对缓存的影响" aria-label="Permalink to &quot;2.用户操作对缓存的影响&quot;">​</a></h3><p><img src="https://segmentfault.com/img/bVbwrBs?w=726&amp;h=254" alt="clipboard.png" title="clipboard.png"></p><p><img src="https://segmentfault.com/img/bVbwrEd?w=998&amp;h=376" alt="clipboard.png" title="clipboard.png"></p><p>下面主要说一下前端优化能入手的地方，也就是<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现的。</p><p><img src="https://segmentfault.com/img/bVbwrEV?w=2288&amp;h=1590" alt="clipboard.png" title="clipboard.png"></p><h3 id="_3-强缓存" tabindex="-1">3.强缓存 <a class="header-anchor" href="#_3-强缓存" aria-label="Permalink to &quot;3.强缓存&quot;">​</a></h3><p>浏览器在第一次访问接口后的response headers里会携带一些字段，这些字段决定关于这个请求的缓存情况，<br> 与强缓存相关的header字段有两个：</p><p>1、<strong>expires：过气网红</strong>，这是<strong>http1.0时的规范</strong>；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源</p><p>2、<strong>cache-control：新星</strong>：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的<strong>max-age</strong>值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；<br><strong>no-cache</strong>：不使用本地缓存。需要使用协商缓存，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p><p><strong>no-store</strong>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p><p><strong>public</strong>：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p><p><strong>private</strong>：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。<br> 　　注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires</p><p>强缓存时段命中，会直接从缓存中返回数据，返回值200；这一时间段，不管接口内容有没有变化都不会进行请求更新。</p><h3 id="_4-协商缓存" tabindex="-1">4.协商缓存 <a class="header-anchor" href="#_4-协商缓存" aria-label="Permalink to &quot;4.协商缓存&quot;">​</a></h3><p>当没有强缓存时，会向服务端寻求帮助，也就是问一下服务端有没有更改，向接口判断是否有缓存。如果命中协商缓存则返回304状态码，并且从本地返回缓存内容。如果没有命中，则重新发起请求。<br> 协商缓存需要跟服务端通过特殊标示连接，即第一次请求的响应头带上某个字段（<strong>Last-Modified</strong>或者<strong>Etag</strong>），则后续请求则会带上对应的请求字段（<strong>If-Modified-Since</strong>或者<strong>If-None-Match</strong>），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><p><strong>具体过程如下：</strong></p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>1.浏览器第一次跟服务器请求一个资源，respone的header里加上Last-Modified：表示这个资源在服务器上的<strong>最后修改时间</strong></p><p>2.浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header：上一次请求时返回的Last-Modified的值</p><p>3.服务器再次收到资源请求时，会判断<strong>最后修改时间</strong>是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容，Last-Modified会被修改为最新的值。如果没有变化，服务器返回304 Not Modified，Last-Modified不会修改，response header中不会再添加Last-Modified的header</p><p>4.浏览器收到304的响应后，就会从缓存中加载资源</p><p><strong>Etag/If-None-Match</strong></p><p>由服务器生成的<strong>每个资源的唯一标识字符串</strong>，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个<strong>ETag返回</strong>，即使这个ETag跟之前的没有变化。</p><p>1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p><p>2.某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p><p>3.某些服务器不能精确的得到文件的最后修改时间。</p><p><strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</strong></p><h2 id="二、浏览器本地存储" tabindex="-1">二、浏览器本地存储 <a class="header-anchor" href="#二、浏览器本地存储" aria-label="Permalink to &quot;二、浏览器本地存储&quot;">​</a></h2><p>浏览器本地缓存最常用的是cookie、localStroage、sessionStroage、webSql、indexDB。</p><h3 id="_1-cookie使用" tabindex="-1">1.cookie使用 <a class="header-anchor" href="#_1-cookie使用" aria-label="Permalink to &quot;1.cookie使用&quot;">​</a></h3><p>cookie的用法很简单,可以通过服务端设置，js也可以通过documnet.cookie=&quot;名称=值;&quot;（不要忘记以;分割）来设置。<br> cookie的<strong>值</strong>字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).<br> cookie一般用做为登陆态保存、密码、个人信息等关键信息保存使用，所以为了安全也是<strong>遵守同源策略原则</strong>的。<br><strong>可以通过下面参数具体设置：</strong><br> ;<strong>path</strong>=path (例如 &#39;/&#39;, &#39;/mydir&#39;) 如果没有定义，默认为当前文档位置的路径。<br> ;<strong>domain</strong>=domain (例如 &#39;example.com&#39;， &#39;subdomain.example.com&#39;) 如果没有定义，默认为当前文档位置的路径的域名部分。与早期规范相反的是，在域名前面加 . 符将会被忽视，因为浏览器也许会拒绝设置这样的cookie。如果指定了一个域，那么子域也包含在内。<br> ;**max-age=**max-age-in-seconds (例如一年为60_60_24*365)<br> ;<strong>expires</strong>=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString()<br> ;<strong>secure</strong> (cookie只通过https协议传输)<br> ;<strong>HttpOnly</strong> 限制web页面程序的browser端script程序读取cookie</p><p><strong>缺点</strong><br> 容量有限制，不能超过4kb<br> 在请求头上带着数据安全性差</p><h3 id="_2-localstorage和sessionstorage使用" tabindex="-1">2.localStorage和sessionStorage使用 <a class="header-anchor" href="#_2-localstorage和sessionstorage使用" aria-label="Permalink to &quot;2.localStorage和sessionStorage使用&quot;">​</a></h3><p>html5新增本地存储，localStorage生命周期是永久，除非主动清除localStorage信息，否则这些信息将<strong>永远存在</strong>。存放数据大小为一般为5MB,sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。也是<strong>遵守同源策略原则</strong>的</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1、保存数据到本地</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 第一个参数是保存的变量名，第二个是赋给变量的值</span></span>
<span class="line"><span style="color:#BABED8;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setItem</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">value</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//复杂类型储存需要**利用JSON.stringify**将对象转换成字符串；</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//利用**JSON.parse**将字符串转换成对象</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2、从本地存储获取数据</span></span>
<span class="line"><span style="color:#BABED8;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getItem</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 3、从本地存储删除某个已保存的数据</span></span>
<span class="line"><span style="color:#BABED8;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">removeItem</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">key</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 4、清除所有保存的数据</span></span>
<span class="line"><span style="color:#BABED8;">localStorage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">clear</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_3-web-sql" tabindex="-1">3. Web SQL <a class="header-anchor" href="#_3-web-sql" aria-label="Permalink to &quot;3\\. Web SQL&quot;">​</a></h3><p>WebSQL是前端的一个独立模块，是web存储方式的一种，我们调试的时候会经常看到，只是一般很少使用。并且，当前只有谷歌支持，ie和火狐均不支持。<br> 主要方法：</p><p>1.openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。<br> 2.transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。<br> 3.executeSql：这个方法用于执行实际的 SQL 查询。</p><h3 id="_4-indexdb" tabindex="-1">4.indexDB <a class="header-anchor" href="#_4-indexdb" aria-label="Permalink to &quot;4.indexDB&quot;">​</a></h3><p>IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。<br><strong>具体概念</strong>参考：<a href="https://link.segmentfault.com/?enc=GZHJgzx%2Bzfa9tQUgk0%2FF7A%3D%3D.1a3H80O6A9tAka3Vvk5d19LAFw5%2BHqQ6y7Zhl3SLa9NY2sTpGEBSvmkFzKVJ63CtkrZMjFpI1WfAUkZgtKhPJw%3D%3D" target="_blank" rel="noreferrer">参考文章</a></p>`,46),r=[t];function p(l,i,c,g,d,h){return a(),e("div",null,r)}const D=s(o,[["render",p]]);export{m as __pageData,D as default};
