import{_ as e,o,c as a,N as s}from"./chunks/framework.60272d8a.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/axios/几个实用响应头.md","lastUpdated":1706686109000}'),n={name:"guide/axios/几个实用响应头.md"},t=s(`<h2 id="用头👴解决-前端必知必会的几个实用响应头" tabindex="-1">用头👴解决！前端必知必会的几个实用响应头 <a class="header-anchor" href="#用头👴解决-前端必知必会的几个实用响应头" aria-label="Permalink to &quot;用头👴解决！前端必知必会的几个实用响应头&quot;">​</a></h2><h2 id="📖阅读本文-你将" tabindex="-1">📖阅读本文，你将: <a class="header-anchor" href="#📖阅读本文-你将" aria-label="Permalink to &quot;📖阅读本文，你将:&quot;">​</a></h2><ol><li>学会几个超级超级实用的 <strong>响应头</strong>，解决你工作中遇到的问题。</li><li>不仅解决问题，还能让你在 <strong>和后端、运维撕逼时</strong> 占据上风。</li></ol><h2 id="学习-响应头-很重要吗" tabindex="-1">学习 <strong>响应头</strong> 很重要吗？ <a class="header-anchor" href="#学习-响应头-很重要吗" aria-label="Permalink to &quot;学习 **响应头** 很重要吗？&quot;">​</a></h2><blockquote><p>真的很重要。</p></blockquote><p>不信你看看下面的场景，眼熟不？</p><h2 id="一、预览、下载-让人操碎了心" tabindex="-1">一、<strong>预览</strong>、<strong>下载</strong> 让人操碎了心? <a class="header-anchor" href="#一、预览、下载-让人操碎了心" aria-label="Permalink to &quot;一、**预览**、**下载** 让人操碎了心?&quot;">​</a></h2><h3 id="_1-1-场景" tabindex="-1">1.1 场景 <a class="header-anchor" href="#_1-1-场景" aria-label="Permalink to &quot;1.1 场景&quot;">​</a></h3><p>我不止一次听到同事、群友们讨论这个问题：</p><blockquote><p>“后端提供了一个 <code>txt</code>(或者 <code>pdf</code>/&#39;json&#39; 等)文件的下载 <code>url</code>，可以当我用 <code>a</code> 标签打开时，却变成了预览……怎么办？救！！！”</p></blockquote><p>此时，就会有人上去推荐 <code>FileSaver.js</code> 或者 “手写读流另存为”。</p><p>然后还有人附和...</p><p>我：？？？</p><p>这是需要写代码才能解决的问题吗？</p><p>如果你有了解过 <code>Content-Disposition</code> 这个 <code>Response Header</code>，那你一定知道，只需要响应头上增加一行，问题就能迎刃而解。</p><h3 id="_1-2-介绍" tabindex="-1">1.2 介绍 <a class="header-anchor" href="#_1-2-介绍" aria-label="Permalink to &quot;1.2 介绍&quot;">​</a></h3><p><strong><code>Content-Disposition</code></strong>：这个响应头可以决定内容是 <strong>预览</strong> 还是 <strong>下载</strong>。</p><p>它支持三种格式的值：</p><ol><li><code>Content-Disposition: inline</code><br> 此时，消息体会以页面的一部分或者整个页面的形式展示。（预览）</li><li><code>Content-Disposition: attachment</code><br> 消息体应该被下载，默认文件名和 <code>url</code> 格式有关。</li><li><code>Content-Disposition: attachment; filename=&quot;filename.jpg&quot;</code><br> 消息体应该被下载，默认文件名可指定。</li></ol><blockquote><p>注：如果需要预览，需要配合适当的 <code>Content-Type</code> 食用；</p></blockquote><h3 id="_1-3-示例" tabindex="-1">1.3 示例 <a class="header-anchor" href="#_1-3-示例" aria-label="Permalink to &quot;1.3 示例&quot;">​</a></h3><p>为此，我特意写了一个 <code>express</code> 小示例。</p><p>大抵是在 <code>express</code> 应用下写了三个路由，如下：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">const user = {</span></span>
<span class="line"><span style="color:#babed8;">  name: &quot;摸鱼的春哥&quot;,</span></span>
<span class="line"><span style="color:#babed8;">  blogUrl: &quot;https://juejin.cn/user/1714893870865303&quot;</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">const contentDispositionInline = async (req, res, next) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  res.setHeader(&#39;Content-Disposition&#39;, &#39;inline&#39;)</span></span>
<span class="line"><span style="color:#babed8;">  res.send(user)</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">const contentDispositionFilename = async (req, res, next) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment; filename=&quot;chunge.json&quot;&#39;)</span></span>
<span class="line"><span style="color:#babed8;">  res.send(user)</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">const contentDispositionNoFilename = async (req, res, next) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment&#39;)</span></span>
<span class="line"><span style="color:#babed8;">  res.send(user)</span></span>
<span class="line"><span style="color:#babed8;">}</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>然后我分别访问三个路由，效果差异：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b92606d69564a6cb5fd1bdf0c005370~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h2 id="二、项目升级了-需要客户-清空缓存" tabindex="-1">二、项目升级了，需要客户 <strong>清空缓存</strong> ？ <a class="header-anchor" href="#二、项目升级了-需要客户-清空缓存" aria-label="Permalink to &quot;二、项目升级了，需要客户 **清空缓存** ？&quot;">​</a></h2><h3 id="_2-1-场景" tabindex="-1">2.1 场景 <a class="header-anchor" href="#_2-1-场景" aria-label="Permalink to &quot;2.1 场景&quot;">​</a></h3><p>实施：“客户反馈<code>Bug</code> 还是没修复。”<br> 你：“哥，真修复了，要不你让客户清一下缓存？”<br> 实施：“啊？客户说他不会清……”<br> …… <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27dff5bd3a2546168adcb1d6651dcd91~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>永远不要期望你的客户会进行 <strong>“那些研发才懂”</strong> 的操作。也不要把你的问题，归因到 <strong>浏览器缓存</strong> 上。</p><p><strong>浏览器缓存</strong> 是被发明出来优化用户体验的，并不是被发明出来阻碍用户的。</p><p>因此，理解如何使用 <code>Cache-Control</code> 这个响应头，是前端的必知技能。</p><h3 id="_2-2-介绍" tabindex="-1">2.2 介绍 <a class="header-anchor" href="#_2-2-介绍" aria-label="Permalink to &quot;2.2 介绍&quot;">​</a></h3><p><strong><code>Cache-Control</code></strong>：用来指定缓存机制。</p><p>缓存，作为前端八股文必考知识，相信大家已经耳熟能详。 常见的 <strong><code>Cache-Control</code></strong> 属性如下：</p><table><thead><tr><th>Response Header属性</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>cache-control</td><td>no-store</td><td>不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。</td></tr><tr><td>cache-control</td><td>public</td><td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）</td></tr><tr><td>cache-control</td><td>private</td><td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</td></tr><tr><td>cache-control</td><td>max-age=&lt;1000&gt;</td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td></tr></tbody></table><ul><li>不缓存<br> 不缓存是最容易理解，每一次请求都会从服务端重新获取，不进行任何缓存。<br> 此策略只需要赋予 <code>Cache-Control: no-store</code> 响应头即可。</li><li>强缓存<br> 有些资源文件，几乎不会发生变化（比如已经 <code>hash化命名的文件</code>），则可以直接从本地缓存获取，这就是所谓的 <strong>强缓存</strong> ;<br> 通过 <code>cache-control: public/private</code> 或者 <code>cache-control: max-age=&lt;1000&gt;</code> 都可以指定机制为强缓存。</li><li>协商缓存<br> 这是一种更为复杂缓存机制，无法再通过响应头 <strong>简单粗暴地</strong> 指定实现，而是需要前后端协作配合。<br> 简单来说，每次请求资源前前端会写代前一次的响应 <code>hash</code>，问询服务端 <strong>资源是否发生过变化</strong>，从而达到准确缓存的效果。<br> 本文不赘述，如果有兴趣，可以参考此文：<a href="https://juejin.cn/post/7030781324650610695" title="https://juejin.cn/post/7030781324650610695" target="_blank" rel="noreferrer">juejin.cn/post/703078…</a></li></ul><h3 id="_2-3-实际生产如何运用" tabindex="-1">2.3 实际生产如何运用？ <a class="header-anchor" href="#_2-3-实际生产如何运用" aria-label="Permalink to &quot;2.3 实际生产如何运用？&quot;">​</a></h3><ul><li>凡是名称带有 <code>hash</code> 值的资源，一律可以强缓存。<br> （毕竟内容一旦有变化，名称的<code>hash</code> 也跟着变了）</li><li>凡是通过 <code>cdn</code> 引入的第三方库，均建议携带版本信息，这样也可以强缓存。<br> （比如 <code>/xx/xx/jquery.min.js</code> 切换为 <code>jquery@3.6.0/dist/jquery.min.js</code>）</li><li>凡是 <code>html</code>、<code>ico</code> 这类命名固定的文件，建议一律 <strong>不缓存</strong> 或者 <strong>协商缓存</strong>。</li></ul><h2 id="三、我的-cookie-不可能这么可爱" tabindex="-1">三、我的 <code>Cookie</code> 不可能这么可爱！ <a class="header-anchor" href="#三、我的-cookie-不可能这么可爱" aria-label="Permalink to &quot;三、我的 \`Cookie\` 不可能这么可爱！&quot;">​</a></h2><h3 id="_3-1-场景" tabindex="-1">3.1 场景 <a class="header-anchor" href="#_3-1-场景" aria-label="Permalink to &quot;3.1 场景&quot;">​</a></h3><blockquote><p>&quot;春哥春哥，为啥我登录成功了，请求还是 <code>401</code> ？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，为啥我存进 <code>cookie</code> 的值取不到？&quot;</p></blockquote><blockquote><p>&quot;春哥春哥，这破 <code>cookie</code> 是不是坏了，浏览器里看明明有值，为啥我访问不了？&quot;</p></blockquote><p>我：“兄弟，你有了解过一个叫 <code>set-cookie</code> 的响应头吗？”</p><h3 id="_3-2-介绍" tabindex="-1">3.2 介绍 <a class="header-anchor" href="#_3-2-介绍" aria-label="Permalink to &quot;3.2 介绍&quot;">​</a></h3><p><code>Cookie</code> 曾经是 <code>Web</code> 开发无法绕开的一道门槛，而现在它的存在感越来越弱，但海量的存量项目并不会因为技术的趋势而消失，它们依然很有价值，依然需要维护。</p><p>而 <code>set-cookie</code> 响应头正是 <code>Cookie</code> 体系中最为核心的 <strong>第一主角</strong>。</p><p><strong><code>Set-Cookie</code></strong>: 是一个响应头，服务端赋值，让浏览器端产生 <code>Cookie</code>，并限定 <code>Cookie</code> 的各种特性。</p><p>这些特性就包括：</p><ul><li>过期时限；<code>Expires=&lt;date&gt;</code></li><li>存活周期；<code>Max-Age=&lt;number&gt;</code><br> 在 cookie 失效之前需要经过的秒数。<code>0</code> 或 <code>-1</code> 直接失效；此属性的优先级高于 <code>Expires</code>。</li><li>域名；<code>Domain=&lt;domain-value&gt;</code><br> 指定 <code>cookie</code> 只能在什么域下生成；（允许通配，这个属性主要出于安全性）</li><li>路径；<code>Path=&lt;path-value&gt;</code><br> 比 <code>Domain</code> 更为细致的控制策略，甚至指定了 <code>xx</code> 路径下才能发送 <code>Cookie</code>。</li><li>只在 <code>Https</code> 产生；<code>Secure</code><br> 如果 <code>set-cookie</code> 头中有 <code>Secure</code> 属性，那么浏览器只会在 <code>Https</code> 环境产生和发送 <code>Cookie</code>。</li><li>禁用 <code>js</code> 操作 <code>API</code>；<code>HttpOnly</code><br> 如果 <code>set-cookie</code> 头中有 <code>HttpOnly</code> 属性，那么 <code>Cookie</code> 属性的生成、读写、发送就只能由浏览器通过 &quot;响应头&quot; 控制了，不在允许前端通过 <code>js</code> 操作 <code>Cookie</code>。</li><li>是否允许跨域携带；<code>SameSite=&lt;samesite-value&gt;</code><br> 支持属性包括 <code>Strict</code>、<code>Lax</code>、<code>None</code>，分别表示： <ul><li><code>Strict</code>: 完全不能跨域携带；</li><li><code>Lax</code>: 只允许从外站导航到源站时携带 <code>Cookie</code></li><li><code>None</code>：跨域也行，不限制。</li></ul></li></ul><h3 id="_3-3-开发常见问题分析" tabindex="-1">3.3 开发常见问题分析 <a class="header-anchor" href="#_3-3-开发常见问题分析" aria-label="Permalink to &quot;3.3 开发常见问题分析&quot;">​</a></h3><ul><li><p>为啥你登录成功了，请求还是 <code>401</code>？</p><p>早期非常多的项目，使用 <code>Cookie</code> 作为用户身份识别的手段，比如 <code>Spring MVC</code> 项目就是通过给 <code>Cookie</code> 一个 <code>JSeesionId</code> 的值作为识别，判断你是否出于当前会话。</p><p>而 &quot;登录了，却还 <code>401</code>&quot; 这个现象，如果服务端没有问题的话，多半是 <strong>浏览器其实并未存储Cookie</strong>。</p><p>换个说法，你每次发起请求，服务端都认为你是一次 <strong>新的会话</strong>，和上一次 <strong>登录的你</strong> 并非同一人。</p><p>如果你正处于 <code>http</code> 环境，那你可能需要暂时移除 <code>Secure</code> 属性。</p></li><li><p>存不进、取不出？<br> 先确认 <strong>是否有域的限制</strong>、<strong>是否有路径的限制</strong>、<strong>是否有 <code>HttpOnly</code></strong>?<br> 逐一排查下来，问题不难解决。</p></li></ul>`,53),c=[t];function l(r,d,i,p,b,u){return o(),a("div",null,c)}const m=e(n,[["render",l]]);export{g as __pageData,m as default};
