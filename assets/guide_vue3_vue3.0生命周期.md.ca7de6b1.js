import{_ as e,o,c as t,N as s}from"./chunks/framework.60272d8a.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"guide/vue3/vue3.0生命周期.md","lastUpdated":1706686109000}'),a={name:"guide/vue3/vue3.0生命周期.md"},r=s(`<h2 id="vue3-0生命周期" tabindex="-1">vue3.0生命周期 <a class="header-anchor" href="#vue3-0生命周期" aria-label="Permalink to &quot;vue3.0生命周期&quot;">​</a></h2><h2 id="一、图示vue2-0到vue3-0改变" tabindex="-1">一、图示vue2.0到vue3.0改变 <a class="header-anchor" href="#一、图示vue2-0到vue3-0改变" aria-label="Permalink to &quot;一、图示vue2.0到vue3.0改变&quot;">​</a></h2><ul><li><p><strong>~<code>beforeCreate</code>~-&gt; use<code>setup()</code></strong></p></li><li><p><strong>~<code>created</code>~-&gt; use<code>setup()</code></strong></p></li><li><p><strong><code>beforeMount</code>-&gt;<code>onBeforeMount</code></strong></p></li><li><p><strong><code>mounted</code>-&gt;<code>onMounted</code></strong></p></li><li><p><strong><code>beforeUpdate</code>-&gt;<code>onBeforeUpdate</code></strong></p></li><li><p><strong><code>updated</code>-&gt;<code>onUpdated</code></strong></p></li><li><p><strong><code>beforeUnmount</code>-&gt;<code>onBeforeUnmount</code></strong></p></li><li><p><strong><code>unmounted</code>-&gt;<code>onUnmounted</code></strong></p></li><li><p><strong><code>errorCaptured</code>-&gt;<code>onErrorCaptured</code></strong></p></li><li><p><strong><code>renderTracked</code>-&gt;<code>onRenderTracked</code></strong></p></li><li><p><strong><code>renderTriggered</code>-&gt;<code>onRenderTriggered</code></strong></p></li><li><p><strong><code>activated</code>-&gt;<code>onActivated</code></strong></p></li><li><p><strong><code>deactivated</code>-&gt;<code>onDeactivated</code></strong></p></li></ul><h2 id="二、解析图示的改变" tabindex="-1">二、解析图示的改变 <a class="header-anchor" href="#二、解析图示的改变" aria-label="Permalink to &quot;二、解析图示的改变&quot;">​</a></h2><p>1、去掉了vue2.0中的 beforeCreate 和 created 两个阶段，同样的新增了一个 <strong>setup</strong></p><p>2、beforeMount 挂载之前 改名 onBeforeMount</p><p>3、mounted 挂载之后 改名 onMounted</p><p>4、beforeUpdate 数据更新之前 改名 onBeforeUpdate</p><p>5、updated 数据更新之后 改名 onUpdated</p><p>6、beforeDestroy销毁前 改名 <strong>onBeforeUnmount</strong></p><p>7、destoryed销毁后 改名 <strong>onUnmounted</strong></p><p>8、errorCaptured 报错 改名 onErrorCaptured</p><h2 id="三、官方对生命周期钩子的解释" tabindex="-1">三、官方对<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">生命周期</a>钩子的解释 <a class="header-anchor" href="#三、官方对生命周期钩子的解释" aria-label="Permalink to &quot;三、官方对[生命周期](https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1001.2101.3001.7020)钩子的解释&quot;">​</a></h2><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p><p>下表包含如何在<a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html" target="_blank" rel="noreferrer">setup ()</a>内部调用生命周期钩子：</p><table><thead><tr><th>选项式 API</th><th>Hook inside<code>setup</code></th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>Not needed*</td></tr><tr><td><code>created</code></td><td>Not needed*</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted</code></td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td></tr></tbody></table><p>TIP</p><p>因为<code>setup</code>是围绕<code>beforeCreate</code>和<code>created</code>生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在<code>setup</code>函数中编写。</p><p>这些函数接受一个回调函数，当钩子被组件调用时将会被执行:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">export default {setup() {onMounted(() =&gt; {console.log(&#39;Component is mounted!&#39;)    })  }}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="四、官方对setup-的详细介绍" tabindex="-1">四、官方对Setup 的详细介绍 <a class="header-anchor" href="#四、官方对setup-的详细介绍" aria-label="Permalink to &quot;四、官方对Setup 的详细介绍&quot;">​</a></h2><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h2><p>使用<code>setup</code>函数时，它将接受两个参数：</p><ol><li><code>props</code></li><li><code>context</code></li></ol><p>让我们更深入地研究如何使用每个参数。</p><h3 id="props" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#props" target="_blank" rel="noreferrer">#</a>Props <a class="header-anchor" href="#props" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#props)Props&quot;">​</a></h3><p><code>setup</code>函数中的第一个参数是<code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code>函数中的<code>props</code>是响应式的，当传入新的 prop 时，它将被更新。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">export default {props: {title: String  },setup(props) {console.log(props.title)  }}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>WARNING</p><p>但是，因为<code>props</code>是响应式的，你<strong>不能使用 ES6 解构</strong>，因为它会消除 prop 的响应性。</p><p>如果需要解构 prop，可以通过使用<code>setup</code>函数中的<a href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84" target="_blank" rel="noreferrer"><code>toRefs</code></a>来完成此操作：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">import { toRefs } from &#39;vue&#39;setup(props) {const { title } = toRefs(props)console.log(title.value)}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果<code>title</code>是可选的 prop，则传入的<code>props</code>中可能没有<code>title</code>。在这种情况下，<code>toRefs</code>将不会为<code>title</code>创建一个 ref 。你需要使用<code>toRef</code>替代它：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">import { toRef } from &#39;vue&#39;setup(props) {const title = toRef(props, &#39;title&#39;)console.log(title.value)}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="context" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#context" target="_blank" rel="noreferrer">#</a>Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#context)Context&quot;">​</a></h3><p>传递给<code>setup</code>函数的第二个参数是<code>context</code>。<code>context</code>是一个普通的 JavaScript 对象，它暴露三个组件的 property：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">export default {setup(props, context) {console.log(context.attrs)console.log(context.slots)console.log(context.emit)  }}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>context</code>是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对<code>context</code>使用 ES6 解构。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">export default {setup(props, { attrs, slots, emit }) {    ...  }}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>attrs</code>和<code>slots</code>是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以<code>attrs.x</code>或<code>slots.x</code>的方式引用 property。请注意，与<code>props</code>不同，<code>attrs</code>和<code>slots</code>是<strong>非</strong>响应式的。如果你打算根据<code>attrs</code>或<code>slots</code>更改应用副作用，那么应该在<code>onUpdated</code>生命周期钩子中执行此操作。</p><h2 id="访问组件的-property" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E8%AE%BF%E9%97%AE%E7%BB%84%E4%BB%B6%E7%9A%84-property" target="_blank" rel="noreferrer">#</a>访问组件的 property <a class="header-anchor" href="#访问组件的-property" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E8%AE%BF%E9%97%AE%E7%BB%84%E4%BB%B6%E7%9A%84-property)访问组件的 property&quot;">​</a></h2><p>执行<code>setup</code>时，组件实例尚未被创建。因此，你只能访问以下 property：</p><ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul><p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p><ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li></ul><h2 id="结合模板使用" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E7%BB%93%E5%90%88%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8" target="_blank" rel="noreferrer">#</a>结合模板使用 <a class="header-anchor" href="#结合模板使用" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E7%BB%93%E5%90%88%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8)结合模板使用&quot;">​</a></h2><p>如果<code>setup</code>返回一个对象，则可以在组件的模板中像传递给<code>setup</code>的<code>props</code>property 一样访问该对象的 property：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">&lt;template&gt;&lt;div&gt;{{ readersNumber }} {{ book.title }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { ref, reactive } from &#39;vue&#39;export default {setup() {const readersNumber = ref(0)const book = reactive({ title: &#39;Vue 3 Guide&#39; })return {        readersNumber,        book      }    }  }&lt;/script&gt;</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>注意，从<code>setup</code>返回的<a href="https://v3.cn.vuejs.org/api/refs-api.html#ref" target="_blank" rel="noreferrer">refs</a>在模板中访问时是<a href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#ref-%E8%A7%A3%E5%BC%80" target="_blank" rel="noreferrer">被自动解开</a>的，因此不应在模板中使用<code>.value</code>。</p><h2 id="使用渲染函数" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0" target="_blank" rel="noreferrer">#</a>使用渲染函数 <a class="header-anchor" href="#使用渲染函数" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0)使用渲染函数&quot;">​</a></h2><p><code>setup</code>还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">import { h, ref, reactive } from &#39;vue&#39;export default {setup() {const readersNumber = ref(0)const book = reactive({ title: &#39;Vue 3 Guide&#39; })return () =&gt; h(&#39;div&#39;, [readersNumber.value, book.title])  }}</span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="使用this" tabindex="-1"><a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8-this" target="_blank" rel="noreferrer">#</a>使用<code>this</code> <a class="header-anchor" href="#使用this" aria-label="Permalink to &quot;[#](https://v3.cn.vuejs.org/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8-this)使用\`this\`&quot;">​</a></h2><p><strong>在<code>setup()</code>内部，<code>this</code>不会是该活跃实例的引用</strong>，因为<code>setup()</code>是在解析其它组件选项之前被调用的，所以<code>setup()</code>内部的<code>this</code>的行为与其它选项中的<code>this</code>完全不同。这在和其它选项式 API 一起使用<code>setup()</code>时可能会导致混淆。</p><h2 id="访问组件的-property-1" tabindex="-1">访问组件的 property <a class="header-anchor" href="#访问组件的-property-1" aria-label="Permalink to &quot;访问组件的 property&quot;">​</a></h2><p>执行<code>setup</code>时，组件实例尚未被创建。因此，你只能访问以下 property：</p><ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul><p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p><ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li></ul>`,59),d=[r];function n(p,c,l,i,u,h){return o(),t("div",null,d)}const m=e(a,[["render",n]]);export{g as __pageData,m as default};
