import{_ as e,o as a,c as s,N as n}from"./chunks/framework.60272d8a.js";const u=JSON.parse('{"title":"前端使用 WebSocket 的四大注意事项（线上踩坑，含泪分享）","description":"","frontmatter":{},"headers":[],"relativePath":"guide/js/前端使用 WebSocket 的四大注意事项.md","lastUpdated":1706686109000}'),o={name:"guide/js/前端使用 WebSocket 的四大注意事项.md"},r=n(`<h1 id="前端使用-websocket-的四大注意事项-线上踩坑-含泪分享" tabindex="-1">前端使用 WebSocket 的四大注意事项（线上踩坑，含泪分享） <a class="header-anchor" href="#前端使用-websocket-的四大注意事项-线上踩坑-含泪分享" aria-label="Permalink to &quot;前端使用 WebSocket 的四大注意事项（线上踩坑，含泪分享）&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p><a href="https://juejin.cn/post/7090171872356089870" title="https://juejin.cn/post/7090171872356089870" target="_blank" rel="noreferrer">联机桌游网页</a>（斗地主、五子棋等），可以和朋友联机玩游戏，不用下载就能一起玩。</p><p><strong>其中的联机功能，就是通过WebSocket实现的，中途也踩了一些坑，分享给大家。</strong></p><h2 id="ws-close-有个参数-最好填上" tabindex="-1">ws.close()有个参数，最好填上 <a class="header-anchor" href="#ws-close-有个参数-最好填上" aria-label="Permalink to &quot;ws.close()有个参数，最好填上&quot;">​</a></h2><p>这个参数就是错误码，表明了关闭连接的原因：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cf60fc94d474ef79ffbaa8ea9b4596f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><p>WebSocket断开连接时，会发送一个错误码给另一方。如果是浏览器主动断开连接，浏览器发错误码给服务器。如果是服务器断开连接，服务器发错误码给浏览器。</p><p>所有错误码可参考 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCloseEvent%2Fcode" title="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code" target="_blank" rel="noreferrer">MDN: CloseEvent Code</a>。</p><p>在浏览器中，调用<code>ws.close()</code>函数关闭连接时，默认错误码是1005，含义是 no status code was provided even though one was expected。</p><p>这是容易犯错的，可能很多人认为它的默认值是1000（正常关闭）。结果服务器收到的却是1005。</p><h2 id="解决" tabindex="-1">解决 <a class="header-anchor" href="#解决" aria-label="Permalink to &quot;解决&quot;">​</a></h2><p>如果前端关闭是正常关闭，你可以使用<code>ws.close(1000)</code>。</p><p>如果前端关闭不是正常关闭，你需要自定义一个异常错误码，范围是4000-4999。</p><p>此外，如果你在开发一个框架，那么你可用的错误码范围是3000-3999。</p><h2 id="如果接收的数据是二进制-一定要设置ws-binarytype" tabindex="-1">如果接收的数据是二进制，一定要设置ws.binaryType <a class="header-anchor" href="#如果接收的数据是二进制-一定要设置ws-binarytype" aria-label="Permalink to &quot;如果接收的数据是二进制，一定要设置ws.binaryType&quot;">​</a></h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e549ade723a942f48043b2a51ba3b888~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><p><code>ws.binaryType</code>有2种值：<code>blob</code>和<code>arraybuffer</code>。</p><p><code>blob</code>是它的默认值。</p><p>如果你收到了二进制数据：当<code>ws.binaryType</code>为<code>blob</code>时，event.data是Blob类型，你需要调用<code>await event.data.arrayBuffer()</code>获取ArrayBuffer类型的数据。</p><p>如果你收到了二进制数据，当<code>ws.binaryType</code>为<code>arraybuffer</code>时，event.data是ArrayBuffer类型。</p><h2 id="踩坑点" tabindex="-1">踩坑点 <a class="header-anchor" href="#踩坑点" aria-label="Permalink to &quot;踩坑点&quot;">​</a></h2><p>我的《联机桌游合集》刚上线时，有个使用iOS的朋友告诉我，她无法进入游戏，重试了多次也不行。</p><p>但是我已经用我手头的安卓、iPad、iPhone、Mac、Windows全都测试过一遍了。</p><p>经过排查，才发现是她的iOS14中Safari浏览器搞的鬼。虽然我没有设置<code>ws.binaryType</code>为<code>arraybuffer</code>， 但是因为Safari检测到是二进制数据，就直接把<code>event.data</code>转换为了ArrayBuffer类型，不是Blob类型，导致我调用<code>await event.data.arrayBuffer()</code>时出错了。</p><p>回顾当时的commit记录：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595b607806634f229d77e78668968563~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><h2 id="解决-1" tabindex="-1">解决 <a class="header-anchor" href="#解决-1" aria-label="Permalink to &quot;解决&quot;">​</a></h2><p>如果你ws收到的数据都是二进制格式，在调用<code>const ws = new WebSocket()</code>后，立马设置<code>ws.binaryType = &#39;arraybuffer&#39;</code>。</p><p>但是如果你ws可能收到二进制数据，也可能收到文本数据，建议参考MDN官方案例，设置<code>ws.binaryType</code>为<code>arraybuffer</code>，但是加个条件判断：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">const ws = new WebSocket(&quot;ws://localhost:8080&quot;);</span></span>
<span class="line"><span style="color:#babed8;">// Change binary type from &quot;blob&quot; to &quot;arraybuffer&quot;</span></span>
<span class="line"><span style="color:#babed8;">ws.binaryType = &quot;arraybuffer&quot;;</span></span>
<span class="line"><span style="color:#babed8;">ws.onmessage = (event) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">    if(event.data instanceof ArrayBuffer) {</span></span>
<span class="line"><span style="color:#babed8;">        // binary frame</span></span>
<span class="line"><span style="color:#babed8;">        console.log(event.data);</span></span>
<span class="line"><span style="color:#babed8;">    } else {</span></span>
<span class="line"><span style="color:#babed8;">        // text frame</span></span>
<span class="line"><span style="color:#babed8;">        console.log(event.data);</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">});</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="关于消息合并与拆分" tabindex="-1">关于消息合并与拆分 <a class="header-anchor" href="#关于消息合并与拆分" aria-label="Permalink to &quot;关于消息合并与拆分&quot;">​</a></h2><p>我在Mac环境下，使用Safari浏览器和Chrome浏览器的WebSocket，有2种不同的现象：</p><p>如果后端发送给前端的消息中，包含了<code>\\n</code>换行符。在Chrome中，会触发多次<code>onmessage</code>事件，各个消息是被Chrome基于<code>\\n</code>分割开了，分割后的消息按顺序依次触发<code>onmessage</code>来处理。在Safari中，只触发了一次<code>onmessage</code>事件，Safari没有帮我们分隔消息。</p><p>事实上，在WebSocket消息中，<code>\\n</code>换行符本身就是区分消息的特殊符号。如果需要短时间内连续发送多条消息给客户端，一种常见的优化手段就是把这些消息一次性发送过去，用<code>\\n</code>分割。</p><p>Chrome做的很好，帮我们分割好了。但是像Safari这种浏览器没有帮我们分割，为了兼容性，我们也需要处理下。</p><h2 id="解决-2" tabindex="-1">解决 <a class="header-anchor" href="#解决-2" aria-label="Permalink to &quot;解决&quot;">​</a></h2><p>如果后端有「批量发送」的机制，就在<code>onmessage</code>事件中，把消息按<code>\\n</code>分割后，再依次处理。如果后端没有实现「批量发送」的机制，则可以忽略。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">ws.onmessage = (event) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  event.data.split(&#39;\\n&#39;).forEach((message) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">    // 处理各个message</span></span>
<span class="line"><span style="color:#babed8;">  });</span></span>
<span class="line"><span style="color:#babed8;">};</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="关于多个ws实例并发" tabindex="-1">关于多个ws实例并发 <a class="header-anchor" href="#关于多个ws实例并发" aria-label="Permalink to &quot;关于多个ws实例并发&quot;">​</a></h2><p>这里的坑不是特别大，但如果你要做压力测试，那就可能会遇到坑。你需要知道：</p><p>Chrome有个特点：如果你同时建立多个WebSocket连接，只会一个一个建立。等前一个ws建立连接成功，后一个ws开始建立连接。</p><blockquote><p>引申阅读：这不是Chrome的特点，而是在 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc6455.txt" title="https://www.rfc-editor.org/rfc/rfc6455.txt" target="_blank" rel="noreferrer">RFC6455</a> 中规定的：</p><p>If the client already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, <strong>the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state.</strong></p><p>更多细节，详见 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc6455.txt" title="https://www.rfc-editor.org/rfc/rfc6455.txt" target="_blank" rel="noreferrer">RFC6455</a> Page 14、Page 15。</p></blockquote><p><strong>如果你想测试后台服务同时被多个客户端连接，是否存在并发问题时，不要用同一个Chrome Tab来测。可以开多个Tab和多个浏览器，或者用Safari测试，也可以用NodeJS来测试。</strong></p><p>因为在Safari上：如果你同时建立多个WebSocket连接，是同时发送ws连接请求的（当然注意ws同时连接数有上限，做压测时，一个Tab没必要一次性连太多，是没用的）。</p><p>我在写文章<a href="https://juejin.cn/post/7126566854037864456" title="https://juejin.cn/post/7126566854037864456" target="_blank" rel="noreferrer">《多房间的聊天室（六）为什么要加锁？不加锁行不行啊？》</a>时，发现了这个问题。</p>`,46),t=[r];function p(c,l,i,b,d,h){return a(),s("div",null,t)}const m=e(o,[["render",p]]);export{u as __pageData,m as default};
